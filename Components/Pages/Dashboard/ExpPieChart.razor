@using ExpenseTracker.Models
@using ExpenseTracker.Service
@using Syncfusion.Blazor.Charts
@using Syncfusion.Blazor.Grids
@implements IDisposable;
@inject ExpenseTracker.Service.ExpenseDataService ExpenseDataService

<div class="pie-chart-container">
    <div class="row pie-chart" id="totalExpense">
        <div class="col-xs-12 col-sm-12 col-md-12">
            <div class="pane col-xs-12 col-sm-12 col-md-12 pie-container">
                <div class="pieChartHeader">
                    <p class="chart-title">Total Expenses</p>
                    <p id="rangeDate" class="chart-value">@Months[@StartDate.Month] @StartDate.Day - @Months[@EndDate.Month] @EndDate.Day</p>
                </div>
                <div class="row">
                    <div class="pieChart">
						@if (Render)
                        {
                            <SfAccumulationChart Height="350px" EnableAnimation="false" EnableSmartLabels="true">
                                <AccumulationChartSeriesCollection>
                                    <AccumulationChartSeries DataSource="@PieRenderingData" XName="Text" YName="Y" Radius="83%" StartAngle="0" EndAngle="360" InnerRadius="50%" Palettes="@palettes">
                                        <AccumulationDataLabelSettings Visible="true" Name="X" Position="AccumulationLabelPosition.Outside">
                                            <AccumulationChartConnector Length="10%"></AccumulationChartConnector>
                                            <AccumulationChartDataLabelFont Color="Black" Size="14px" FontFamily="Roboto"></AccumulationChartDataLabelFont>
                                        </AccumulationDataLabelSettings>
                                    </AccumulationChartSeries>
                                </AccumulationChartSeriesCollection>
                            	<AccumulationChartTooltipSettings Enable="true"></AccumulationChartTooltipSettings>
                            	<AccumulationChartLegendSettings Visible="false"></AccumulationChartLegendSettings>
                        	</SfAccumulationChart>
						}
                    </div>
                    <div class="chartLegend" style="margin: 0 auto;">
						@if (Render)
                        {
                            <SfGrid TValue="LegendRenderData" DataSource="@PieRenderData" Width="100%" AllowSelection="false" GridLines="GridLine.None" EnableHover="false">
                                <GridTemplates>
                                    <RowTemplate>
                                        @{
                                            var legend = (context as LegendRenderData);
                                            var style = "width: 16px; height: 16px; margin-left: 1px; border-radius: 16px; background:" + legend.Color;
                                            <td>
                                                <div style="@style"></div>
                                            </td>
                                            <td> @legend.Text </td>
                                            <td> $@legend.Y </td>
                                            <td style="text-align:right;">@legend.X </td>
                                        }
                                    </RowTemplate>
                                </GridTemplates>
                                <GridColumns>
                                    <GridColumn Field="@nameof(LegendRenderData.Color)" Width="10%" TextAlign="@TextAlign.Center"></GridColumn>
                                    <GridColumn Field="@nameof(LegendRenderData.Text)" Width="50%"></GridColumn>
                                    <GridColumn Field="@nameof(LegendRenderData.Y)" Format="C2" Width="20%"></GridColumn>
                                    <GridColumn Field="@nameof(LegendRenderData.X)" Width="20%"></GridColumn>
                                </GridColumns>
                            </SfGrid>
						}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code{

    [Parameter]
    public IEnumerable<ExpenseData> ExpenseData { get; set; }
    [Parameter]
    public bool Render { get; set; }

    private DateTime StartDate;
    private DateTime EndDate;
    private List<RenderingData> PieRenderingData = new List<RenderingData>();
    private List<LegendRenderData> PieRenderData = new List<LegendRenderData>();
    private string[] palettes = new string[] { "#61EFCD", "#CDDE1F", "#FEC200", "#CA765A", "#2485FA", "#F57D7D", "#C152D2",
                    "#8854D9", "#3D4EB8", "#00BCD7","#4472c4", "#ed7d31", "#ffc000", "#70ad47", "#5b9bd5", "#c1c1c1", "#6f6fe2", "#e269ae", "#9e480e", "#997300" };
    private string[] Months = new string[] { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

    protected override void OnInitialized()
    {
        ExpenseDataService.OnChanged += HandleChanged;
        BuildFromService();
    }
    private void HandleChanged()
    {
        BuildFromService();
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Calculate the total expense and update the pie chart
    /// </summary>
    public void RefreshPieChart(IEnumerable<ExpenseData> expenseData)
    {
        ExpenseData = expenseData;
        UpdatePieChart();
    }

    private void UpdatePieChart()
    {
        // 1) Ventana de fechas (si las usas en la gráfica)
        StartDate = ExpenseDataService?.StartDate ?? DateTime.MinValue;
        EndDate = ExpenseDataService?.EndDate ?? DateTime.MaxValue;

        // 2) Fuente segura (evita NRE)
        var data = (ExpenseData ?? Enumerable.Empty<ExpenseData>())
            .Where(x => x != null)
            .ToList();

        // Si no hay datos, limpia y sal
        if (data.Count == 0)
        {
            PieRenderingData = new List<RenderingData>();
            PieRenderData = new List<LegendRenderData>();
            return;
        }

        // 3) Agrupar por categoría (normalizando nulos/vacíos)
        var grupos = data
            .GroupBy(x => string.IsNullOrWhiteSpace(x.Category) ? "Sin categoría" : x.Category.Trim())
            .Select(g => new
            {
                Categoria = g.Key,
                Total = g.Sum(z => z.Amount) // decimal
            })
            .OrderByDescending(x => x.Total)
            .ToList();

        // 4) Total general (decimal) y guardas división entre cero
        var expTotal = grupos.Sum(x => x.Total);
        if (expTotal <= 0)
        {
            // No tiene sentido calcular porcentajes
            PieRenderingData = new List<RenderingData>();
            PieRenderData = new List<LegendRenderData>();
            return;
        }

        // 5) Construir series para el pie (top-N + Others)
        // Regla original: si hay >10, agrupar desde el índice 9 hacia abajo como "Others"
        var maxSlices = 10;
        var top = grupos.Take(maxSlices - 1).ToList();      // 9
        var rest = grupos.Skip(maxSlices - 1).ToList();     // el resto

        decimal othersTotal = rest.Sum(r => r.Total);
        var renderingData = new List<RenderingData>();
        var legendRender = new List<LegendRenderData>();

        // 6) Paleta segura
        int PaletteCount = palettes?.Length ?? 0;
        string GetColor(int idx) => PaletteCount > 0 ? palettes[idx % PaletteCount] : "";

        // 7) Agregar top categorías
        for (int i = 0; i < top.Count; i++)
        {
            var t = top[i];
            var percent = (t.Total / expTotal) * 100m;
            var color = GetColor(i);

            renderingData.Add(new RenderingData
            {
                X = t.Categoria,
                Y = t.Total, // si tu lib de chart requiere double
                Text = percent.ToString("N2") + '%',
                Fill = color
            });

            legendRender.Add(new LegendRenderData
            {
                X = percent.ToString("N2") + '%',
                Y = (int)t.Total, // si tu grid de leyenda quiere int, si no usa double
                Text = t.Categoria,
                Color = color
            });
        }

        // 8) Agregar "Others" si aplica
        if (othersTotal > 0)
        {
            var idx = top.Count; // siguiente color
            var percent = (othersTotal / expTotal) * 100m;
            var color = GetColor(idx);

            renderingData.Add(new RenderingData
            {
                X = "Others",
                Y = othersTotal,
                Text = percent.ToString("N2") + '%',
                Fill = color
            });

            legendRender.Add(new LegendRenderData
            {
                X = percent.ToString("N2") + '%',
                Y = (int)othersTotal,
                Text = "Others",
                Color = color
            });
        }

        // 9) Salida
        PieRenderingData = renderingData;
        PieRenderData = legendRender;
    }
    private void OnChanged() { BuildFromService(); InvokeAsync(StateHasChanged); }
    private void BuildFromService()
    {
        var data = (ExpenseDataService.ExpenseData ?? new())
                    .Where(x => x != null)
                    .ToList();

        // Si no hay datos, limpia
        if (data.Count == 0) { PieRenderingData = new(); PieRenderData = new(); return; }

        var grupos = data
            .GroupBy(x => string.IsNullOrWhiteSpace(x.Category) ? "Sin categoría" : x.Category.Trim())
            .Select(g => new { Categoria = g.Key, Total = g.Sum(z => z.Amount) })
            .OrderByDescending(x => x.Total)
            .ToList();

        var total = grupos.Sum(x => x.Total);
        if (total <= 0) { PieRenderingData = new(); PieRenderData = new(); return; }

        var maxSlices = 10;
        var top = grupos.Take(maxSlices - 1).ToList();
        var rest = grupos.Skip(maxSlices - 1).ToList();
        var othersTotal = rest.Sum(r => r.Total);

        var rendering = new List<RenderingData>();
        var legend = new List<LegendRenderData>();

        string Color(int i) => palettes.Length == 0 ? "" : palettes[i % palettes.Length];

        for (int i = 0; i < top.Count; i++)
        {
            var t = top[i];
            var pct = (t.Total / total) * 100m;
            var col = Color(i);

            rendering.Add(new RenderingData { X = t.Categoria, Y = t.Total, Text = pct.ToString("N2") + "%", Fill = col });
            legend.Add(new LegendRenderData { X = pct.ToString("N2") + "%", Y = (int)t.Total, Text = t.Categoria, Color = col });
        }

        if (othersTotal > 0)
        {
            var i = top.Count;
            var pct = (othersTotal / total) * 100m;
            var col = Color(i);

            rendering.Add(new RenderingData { X = "Others", Y = othersTotal, Text = pct.ToString("N2") + "%", Fill = col });
            legend.Add(new LegendRenderData { X = pct.ToString("N2") + "%", Y = (int)othersTotal, Text = "Others", Color = col });
        }

        PieRenderingData = rendering;
        PieRenderData = legend;
    }
    public void Dispose() => ExpenseDataService.OnChanged -= HandleChanged;


    private class RenderingData
    {
        public string X { get; set; }
        public decimal Y { get; set; }
        public string Text { get; set; }
        public string Fill { get; set; }
    }

    private class LegendRenderData
    {
        public string X { get; set; }
        public int Y { get; set; }
        public string Text { get; set; }
        public string Color { get; set; }
    }

    
}

<style>
    .chartLegend .e-grid {
        border: none !important;
        box-shadow: none !important;
        min-width: 250px;
    }

    .e-grid tr.e-row {
        height: 30px;
    }
</style>